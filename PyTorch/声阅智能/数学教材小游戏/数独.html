<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ•°ç‹¬æŒ‘æˆ˜</title>
  <style>
    :root {
      --main-blue: #1A365D;
      --white: #FFFFFF;
      --accent-blue: #4299E1;
      --error-red: #E53E3E;
      --origin-gray: #2D3748;
      --user-black: #4A5568;
      --light-gray: #F7FAFC;
      --border-gray: #CBD5E1;
      --success-green: #38A169;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', 'PingFang SC', 'Hiragino Sans', Arial, sans-serif;
      background: linear-gradient(135deg, var(--main-blue) 0%, #2C5282 100%);
      color: var(--main-blue);
      min-height: 100vh;
      padding: 20px;
    }

    .sudoku-container {
      max-width: 900px;
      margin: 0 auto;
      background: var(--white);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(26,54,93,0.15);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* é¡¶éƒ¨å¯¼èˆªæ  */
    .navbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--main-blue);
      color: var(--white);
      padding: 20px 30px;
      position: relative;
    }

    .navbar::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-blue), #63B3ED);
    }

    .navbar-title {
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .navbar-center {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .navbar-select {
      background: var(--white);
      color: var(--main-blue);
      border: none;
      border-radius: 10px;
      padding: 8px 16px;
      font-size: 1.1rem;
      font-weight: 600;
      outline: none;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .navbar-select:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .navbar-counter {
      font-size: 1.1rem;
      font-weight: 600;
      background: var(--accent-blue);
      color: var(--white);
      border-radius: 12px;
      padding: 8px 16px;
      box-shadow: 0 2px 8px rgba(66,153,225,0.3);
    }

    /* ä¸»æ¸¸æˆåŒºåŸŸ */
    .main-area {
      display: flex;
      gap: 30px;
      padding: 30px;
      min-height: 600px;
    }

    .sudoku-board-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
      min-width: 340px;
    }

    .sudoku-board {
      display: grid;
      gap: 2px;
      background: var(--main-blue);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 8px 25px rgba(26,54,93,0.2);
      transition: all 0.3s ease;
    }

    .sudoku-board.mode-4x4 {
      grid-template-columns: repeat(4, 60px);
      grid-template-rows: repeat(4, 60px);
    }

    .sudoku-board.mode-6x6 {
      grid-template-columns: repeat(6, 50px);
      grid-template-rows: repeat(6, 50px);
    }

    .sudoku-board.mode-9x9 {
      grid-template-columns: repeat(9, 45px);
      grid-template-rows: repeat(9, 45px);
      min-width: 320px;
      max-width: 100vw;
      overflow-x: auto;
    }

    .sudoku-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: 600;
      background: var(--white);
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      border-radius: 4px;
      position: relative;
    }

    .sudoku-cell:hover:not(.origin) {
      background: #EBF8FF;
      transform: scale(1.05);
    }

    .sudoku-cell.origin {
      color: var(--origin-gray);
      font-weight: 700;
      background: var(--light-gray);
      cursor: default;
    }

    .sudoku-cell.origin:hover {
      transform: none;
      background: var(--light-gray);
    }

    .sudoku-cell.user {
      color: var(--accent-blue);
      font-weight: 600;
    }

    .sudoku-cell.selected {
      background: #EBF8FF;
      box-shadow: 0 0 0 3px var(--accent-blue);
      transform: scale(1.05);
    }

    .sudoku-cell.error {
      background: #FFF5F5;
      color: var(--error-red);
      box-shadow: 0 0 0 3px var(--error-red);
    }

    .sudoku-cell.correct {
      background: #F0FFF4;
      color: var(--success-green);
      box-shadow: 0 0 0 3px var(--success-green);
    }

    /* æ§åˆ¶é¢æ¿ */
    .control-panel {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      width: 100%;
      gap: 24px;
    }

    .number-select {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .number-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--light-gray);
      color: var(--main-blue);
      font-size: 1.3rem;
      font-weight: 700;
      border: none;
      outline: none;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .number-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }

    .number-btn.selected {
      background: var(--accent-blue);
      color: var(--white);
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(66,153,225,0.4);
    }

    .number-btn.delete {
      background: var(--error-red);
      color: var(--white);
      font-size: 1.5rem;
    }

    .number-btn.delete:hover {
      background: #C53030;
    }

    /* åŠŸèƒ½æŒ‰é’®åŒº */
    .function-btns {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 18px 18px;
      width: 100%;
    }

    .func-btn {
      background: var(--accent-blue);
      color: var(--white);
      border: none;
      border-radius: 12px;
      padding: 10px 16px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(66,153,225,0.3);
      white-space: nowrap;
    }

    .func-btn:hover {
      background: #2B6CB0;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(66,153,225,0.4);
    }

    .func-btn:active {
      transform: translateY(0);
    }

    /* å³ä¾§é¢æ¿ */
    .side-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      background: var(--light-gray);
      border-radius: 16px;
      padding: 25px;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }

    .mode-desc {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent-blue);
      text-align: center;
      padding: 15px;
      background: var(--white);
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .difficulty {
      color: #718096;
      font-size: 1rem;
      font-weight: 500;
      text-align: center;
    }

    .hint {
      color: var(--main-blue);
      font-size: 0.95rem;
      line-height: 1.5;
      background: var(--white);
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid var(--accent-blue);
    }

    .timer {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--main-blue);
      text-align: center;
      background: var(--white);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-family: 'Courier New', monospace;
    }

    .stats {
      background: var(--white);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    .stats-label {
      color: #718096;
    }

    .stats-value {
      font-weight: 600;
      color: var(--main-blue);
    }

    /* æˆåŠŸæç¤º */
    .success-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .success-content {
      background: var(--white);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      max-width: 400px;
    }

    .success-title {
      font-size: 2rem;
      font-weight: 700;
      color: var(--success-green);
      margin-bottom: 15px;
    }

    .success-text {
      font-size: 1.1rem;
      color: var(--main-blue);
      margin-bottom: 25px;
    }

    .success-btn {
      background: var(--accent-blue);
      color: var(--white);
      border: none;
      border-radius: 12px;
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .success-btn:hover {
      background: #2B6CB0;
      transform: translateY(-2px);
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
      .main-area {
        flex-direction: column;
        gap: 20px;
        padding: 20px;
      }

      .side-panel {
        min-width: 0;
        width: 100%;
      }

      .control-panel {
        flex-direction: column;
        gap: 15px;
      }

      .function-btns {
        justify-content: center;
      }

      .navbar {
        padding: 15px 20px;
      }

      .navbar-title {
        font-size: 1.4rem;
      }

      .sudoku-board.mode-4x4 {
        grid-template-columns: repeat(4, 50px);
        grid-template-rows: repeat(4, 50px);
      }

      .sudoku-board.mode-6x6 {
        grid-template-columns: repeat(6, 42px);
        grid-template-rows: repeat(6, 42px);
      }

      .sudoku-board.mode-9x9 {
        grid-template-columns: repeat(9, 36px);
        grid-template-rows: repeat(9, 36px);
        font-size: 0.95rem;
      }

      .sudoku-board-panel {
        min-width: 0;
      }
    }

    .info-message {
      margin-top: 16px;
      text-align: center;
      font-size: 1.08rem;
      font-weight: 600;
      min-height: 1.5em;
      width: 100%;
      border: none;
      background: none;
      box-shadow: none;
    }
    .info-message.info { color: #3182ce; }
    .info-message.success { color: #38A169; }
    .info-message.warn { color: #E53E3E; }
  </style>
</head>
<body>
  <div class="sudoku-container">
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="navbar">
      <div class="navbar-title">ğŸ§© æ•°ç‹¬æŒ‘æˆ˜</div>
      <div class="navbar-center">
        <select class="navbar-select" id="modeSelect">
          <option value="4x4">4Ã—4 ç®€å•</option>
          <option value="6x6">6Ã—6 ä¸­ç­‰</option>
          <option value="9x9">9Ã—9 å›°éš¾</option>
        </select>
      </div>
      <div class="navbar-counter" id="questionCounter">ç¬¬ 1 é¢˜</div>
    </div>

    <!-- ä¸»æ¸¸æˆåŒºåŸŸ -->
    <div class="main-area">
      <!-- æ•°ç‹¬ç½‘æ ¼å’Œæ§åˆ¶é¢æ¿ -->
      <div class="sudoku-board-panel">
        <div class="sudoku-board mode-4x4" id="sudokuBoard">
          <!-- åŠ¨æ€ç”Ÿæˆæ ¼å­ -->
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
          <div class="function-btns">
            <button class="func-btn" id="restartBtn" title="é‡æ–°å¼€å§‹">ğŸ”„ é‡ç©</button>
            <button class="func-btn" id="undoBtn" title="æ’¤é”€ä¸Šä¸€æ­¥">â†¶ æ’¤é”€</button>
            <button class="func-btn" id="checkBtn" title="æ£€æŸ¥ç­”æ¡ˆ">âœ“ æ£€æŸ¥</button>
            <button class="func-btn" id="hintBtn" title="æ˜¾ç¤ºæç¤º">ğŸ’¡ æç¤º <span id="hintCountLabel" style="font-size:0.95em;color:#fff;margin-left:4px;"></span></button>
            <button class="func-btn" id="answerBtn" title="æ˜¾ç¤ºç­”æ¡ˆ" style="display:none;">ğŸ‘ ç­”æ¡ˆ</button>
            <button class="func-btn" id="nextBtn" title="ä¸‹ä¸€é¢˜">ä¸‹ä¸€é¢˜ â†’</button>
          </div>
          <div id="infoMessage" class="info-message"></div>
        </div>
      </div>

      <!-- å³ä¾§é¢æ¿ -->
      <div class="side-panel">
        <div class="mode-desc" id="modeDesc">4Ã—4 ç®€å•æ¨¡å¼</div>
        <div class="difficulty" id="difficultyDesc">éš¾åº¦ï¼šå…¥é—¨ç®€å•</div>
        <div class="hint" id="gameHint">
          ğŸ’¡ æç¤ºï¼šæ¯è¡Œã€æ¯åˆ—å’Œæ¯ä¸ªåŒºåŸŸéƒ½ä¸èƒ½æœ‰é‡å¤æ•°å­—ã€‚ç‚¹å‡»ç©ºæ ¼é€‰æ‹©ï¼Œç„¶åç‚¹å‡»æ•°å­—å¡«å…¥ã€‚
        </div>
        <div class="timer" id="timer">00:00:00</div>
        <div class="stats">
          <div class="stats-item">
            <span class="stats-label">å·²å¡«æ ¼æ•°ï¼š</span>
            <span class="stats-value" id="filledCells">0</span>
          </div>
          <div class="stats-item">
            <span class="stats-label">å‰©ä½™ç©ºæ ¼ï¼š</span>
            <span class="stats-value" id="emptyCells">0</span>
          </div>
          <div class="stats-item">
            <span class="stats-label">é”™è¯¯æ¬¡æ•°ï¼š</span>
            <span class="stats-value" id="errorCount">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- æˆåŠŸæç¤ºæ¨¡æ€æ¡† -->
  <div class="success-modal" id="successModal">
    <div class="success-content">
      <div class="success-title">ğŸ‰ æ­å–œå®Œæˆï¼</div>
      <div class="success-text" id="successText">
        æ‚¨ç”¨æ—¶ <span id="finalTime">00:00:00</span> å®Œæˆäº†è¿™é“æ•°ç‹¬é¢˜ï¼
      </div>
      <button class="success-btn" id="nextQuestionBtn">ä¸‹ä¸€é¢˜</button>
    </div>
  </div>

  <script>
    console.log('script loaded'); // æ£€æŸ¥è„šæœ¬æ˜¯å¦åŠ è½½
    class SudokuGame {
      constructor() {
        console.log('SudokuGame constructor');
        this.currentMode = '4x4';
        this.currentQuestion = 1;
        this.totalQuestions = 10;
        this.selectedCell = null;
        this.selectedNumber = null;
        this.gameBoard = [];
        this.originalBoard = [];
        this.userMoves = [];
        this.startTime = null;
        this.timerInterval = null;
        this.errorCount = 0;
        this.isGameComplete = false;
        this.hintCount = 3; // åˆå§‹æç¤ºæ¬¡æ•°
        this.answerAvailable = false; // ç­”æ¡ˆæŒ‰é’®æ˜¯å¦å¯è§
        this.handleKeydown = this.handleKeydown.bind(this);
        this.initializeGame();
        this.bindEvents();
        this.startTimer();
      }

      initializeGame() {
        console.log('initializeGame');
        this.generateBoard();
        this.renderBoard();
        this.hintCount = 3;
        this.answerAvailable = false;
        this.updateHintLabel();
        this.updateAnswerBtn();
      }

      generateBoard() {
        const size = parseInt(this.currentMode.split('x')[0]);
        console.log('[generateBoard] å½“å‰æ¨¡å¼:', this.currentMode, 'size:', size);
        let valid = false;
        let tryCount = 0;
        while (!valid && tryCount < 20) {
            // 1. ç”Ÿæˆå®Œæ•´ç›˜é¢
            const fullBoard = this.generateCompleteSudoku(size);
            console.log('[generateBoard] fullBoard:', fullBoard);
            // 2. æŒ–ç©ºï¼Œå¾—åˆ°åˆå§‹ç›˜é¢ï¼ˆä¼ é€’å‰¯æœ¬ï¼‰
            const puzzleBoard = JSON.parse(JSON.stringify(fullBoard));
            this.removeNumbers(puzzleBoard, size);
            // 3. å”¯ä¸€æ€§æ ¡éªŒ
            valid = this.checkSudokuValid(fullBoard);
            if (valid) {
                this.fullBoard = JSON.parse(JSON.stringify(fullBoard));
                this.gameBoard = JSON.parse(JSON.stringify(puzzleBoard));
                this.originalBoard = JSON.parse(JSON.stringify(puzzleBoard));
            }
            tryCount++;
        }
        if (!valid) {
            throw new Error('æ— æ³•ç”Ÿæˆåˆæ³•çš„æ•°ç‹¬ç›˜é¢ï¼Œè¯·æ£€æŸ¥æ¨¡æ¿æˆ–ç”Ÿæˆé€»è¾‘ï¼');
        }
        console.log('[generateBoard] ç”Ÿæˆå®Œæˆï¼ŒgameBoard:', this.gameBoard, 'originalBoard:', this.originalBoard, 'fullBoard:', this.fullBoard);
    }

      generateCompleteSudoku(size) {
        console.log('[generateCompleteSudoku] size:', size);
        // ä¿®å¤äºŒç»´æ•°ç»„åˆå§‹åŒ–ï¼Œç¡®ä¿æ¯ä¸€è¡Œéƒ½æ˜¯ç‹¬ç«‹çš„æ•°ç»„
        const board = [];
        for (let i = 0; i < size; i++) {
          board.push(new Array(size).fill(0));
        }
        // ä½¿ç”¨æ›´ç®€å•ä½†æœ‰æ•ˆçš„ç”Ÿæˆæ–¹æ³•
        if (size === 4) {
          console.log('è°ƒç”¨generateSimple4x4');
          this.generateSimple4x4(board);
        } else if (size === 6) {
          console.log('è°ƒç”¨generateSimple6x6');
          this.generateSimple6x6(board);
        } else if (size === 9) {
          console.log('è°ƒç”¨generateSimple9x9');
          this.generateSimple9x9(board);
        }
        console.log('[generateCompleteSudoku] ç”Ÿæˆåboard:', board);
        return board;
      }

      generateSimple4x4(board) {
        // é¢„è®¾ä¸€ä¸ªæœ‰æ•ˆçš„4x4æ•°ç‹¬æ¨¡æ¿
        const templates = [
          [
            [1, 2, 3, 4],
            [3, 4, 1, 2],
            [2, 1, 4, 3],
            [4, 3, 2, 1]
          ],
          [
            [2, 1, 4, 3],
            [4, 3, 2, 1],
            [1, 2, 3, 4],
            [3, 4, 1, 2]
          ],
          [
            [3, 4, 1, 2],
            [1, 2, 3, 4],
            [4, 3, 2, 1],
            [2, 1, 4, 3]
          ]
        ];

        const template = templates[Math.floor(Math.random() * templates.length)];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            board[i][j] = template[i][j];
          }
        }

        // éšæœºæ‰“ä¹±è¡Œå’Œåˆ—
        this.shuffleBoard4x4(board);
      }

      generateSimple6x6(board) {
        // é¢„è®¾ä¸€ä¸ªæœ‰æ•ˆçš„6x6æ•°ç‹¬æ¨¡æ¿
        const template = [
          [1, 2, 3, 4, 5, 6],
          [4, 5, 6, 1, 2, 3],
          [2, 3, 1, 6, 4, 5],
          [5, 6, 4, 3, 1, 2],
          [3, 1, 2, 5, 6, 4],
          [6, 4, 5, 2, 3, 1]
        ];

        for (let i = 0; i < 6; i++) {
          for (let j = 0; j < 6; j++) {
            board[i][j] = template[i][j];
          }
        }

        this.shuffleBoard6x6(board);
      }

      generateSimple9x9(board) {
        // ç»å…¸9x9æ•°ç‹¬æ¨¡æ¿
        const template = [
          [5,3,4,6,7,8,9,1,2],
          [6,7,2,1,9,5,3,4,8],
          [1,9,8,3,4,2,5,6,7],
          [8,5,9,7,6,1,4,2,3],
          [4,2,6,8,5,3,7,9,1],
          [7,1,3,9,2,4,8,5,6],
          [9,6,1,5,3,7,2,8,4],
          [2,8,7,4,1,9,6,3,5],
          [3,4,5,2,8,6,1,7,9]
        ];
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            board[i][j] = template[i][j];
          }
        }
        this.shuffleBoard9x9(board);
      }

      shuffleBoard4x4(board) {
        // éšæœºäº¤æ¢è¡Œï¼ˆåœ¨åŒä¸€ä¸ª2x2åŒºåŸŸå†…ï¼‰
        if (Math.random() > 0.5) {
          [board[0], board[1]] = [board[1], board[0]];
        }
        if (Math.random() > 0.5) {
          [board[2], board[3]] = [board[3], board[2]];
        }

        // éšæœºäº¤æ¢åˆ—ï¼ˆåœ¨åŒä¸€ä¸ª2x2åŒºåŸŸå†…ï¼‰
        if (Math.random() > 0.5) {
          for (let i = 0; i < 4; i++) {
            [board[i][0], board[i][1]] = [board[i][1], board[i][0]];
          }
        }
        if (Math.random() > 0.5) {
          for (let i = 0; i < 4; i++) {
            [board[i][2], board[i][3]] = [board[i][3], board[i][2]];
          }
        }
      }

      shuffleBoard6x6(board) {
        // éšæœºäº¤æ¢è¡Œï¼ˆåœ¨åŒä¸€ä¸ª2x3åŒºåŸŸå†…ï¼‰
        if (Math.random() > 0.5) {
          [board[0], board[1]] = [board[1], board[0]];
        }
        if (Math.random() > 0.5) {
          [board[2], board[3]] = [board[3], board[2]];
        }
        if (Math.random() > 0.5) {
          [board[4], board[5]] = [board[5], board[4]];
        }

        // éšæœºäº¤æ¢åˆ—
        for (let group = 0; group < 2; group++) {
          const start = group * 3;
          if (Math.random() > 0.5) {
            for (let i = 0; i < 6; i++) {
              [board[i][start], board[i][start + 1]] = [board[i][start + 1], board[i][start]];
            }
          }
          if (Math.random() > 0.5) {
            for (let i = 0; i < 6; i++) {
              [board[i][start + 1], board[i][start + 2]] = [board[i][start + 2], board[i][start + 1]];
            }
          }
        }
      }

      shuffleBoard9x9(board) {
            // è¡Œç»„å†…äº¤æ¢
            for (let g = 0; g < 3; g++) {
                const rows = [g * 3, g * 3 + 1, g * 3 + 2];
                if (Math.random() > 0.5) [board[rows[0]], board[rows[1]]] = [board[rows[1]], board[rows[0]]];
                if (Math.random() > 0.5) [board[rows[1]], board[rows[2]]] = [board[rows[2]], board[rows[1]]];
            }
            // è¡Œç»„æ•´ä½“äº¤æ¢
            if (Math.random() > 0.5) {
                [board[0], board[3], board[6]] = [board[6], board[0], board[3]];
                [board[1], board[4], board[7]] = [board[7], board[1], board[4]];
                [board[2], board[5], board[8]] = [board[8], board[2], board[5]];
            }
            // åˆ—ç»„å†…äº¤æ¢
            for (let g = 0; g < 3; g++) {
                const cols = [g * 3, g * 3 + 1, g * 3 + 2];
                if (Math.random() > 0.5) for (let i = 0; i < 9; i++) [board[i][cols[0]], board[i][cols[1]]] = [board[i][cols[1]], board[i][cols[0]]];
                if (Math.random() > 0.5) for (let i = 0; i < 9; i++) [board[i][cols[1]], board[i][cols[2]]] = [board[i][cols[2]], board[i][cols[1]]];
            }
            // åˆ—ç»„æ•´ä½“äº¤æ¢
            if (Math.random() > 0.5) {
                for (let i = 0; i < 9; i++) {
                [board[i][0], board[i][3], board[i][6]] = [board[i][6], board[i][0], board[i][3]];
                [board[i][1], board[i][4], board[i][7]] = [board[i][7], board[i][1], board[i][4]];
                [board[i][2], board[i][5], board[i][8]] = [board[i][8], board[i][2], board[i][5]];
                }
            }
    }

      isValidMove(board, row, col, num, size) {
        // æ£€æŸ¥è¡Œ
        for (let x = 0; x < size; x++) {
          if (x !== col && board[row][x] === num) return false;
        }

        // æ£€æŸ¥åˆ—
        for (let x = 0; x < size; x++) {
          if (x !== row && board[x][col] === num) return false;
        }

        // æ£€æŸ¥åŒºåŸŸ
        let regionRows, regionCols;
        if (size === 4) {
          regionRows = regionCols = 2;
        } else if (size === 6) {
          regionRows = 2;
          regionCols = 3;
        } else if (size === 9) {
          regionRows = 3;
          regionCols = 3;
        }

        const startRow = Math.floor(row / regionRows) * regionRows;
        const startCol = Math.floor(col / regionCols) * regionCols;

        for (let i = 0; i < regionRows; i++) {
          for (let j = 0; j < regionCols; j++) {
            const checkRow = i + startRow;
            const checkCol = j + startCol;
            if (checkRow !== row && checkCol !== col && board[checkRow][checkCol] === num) {
              return false;
            }
          }
        }

        return true;
      }

      removeNumbers(board, size) {
        const totalCells = size * size;
        let cellsToRemove;
        switch(this.currentMode) {
          case '4x4': cellsToRemove = Math.floor(totalCells * 0.5); break;
          case '6x6': cellsToRemove = Math.floor(totalCells * 0.55); break;
          case '9x9': cellsToRemove = Math.floor(totalCells * 0.6); break;
        }
        const positions = [];
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            positions.push([i, j]);
          }
        }
        this.shuffleArray(positions);
        for (let i = 0; i < cellsToRemove; i++) {
          const [row, col] = positions[i];
          board[row][col] = 0;
        }
      }

      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      renderBoard() {
        console.log('[renderBoard] æ¸²æŸ“ç›˜é¢ï¼Œå½“å‰æ¨¡å¼:', this.currentMode, 'gameBoard:', this.gameBoard);
        const board = document.getElementById('sudokuBoard');
        console.log('sudokuBoard dom:', board);
        const size = parseInt(this.currentMode.split('x')[0]);
        let regionRows = 2, regionCols = 2;
        if (size === 6) { regionRows = 2; regionCols = 3; }
        else if (size === 9) { regionRows = 3; regionCols = 3; }
        board.className = `sudoku-board mode-${this.currentMode}`;
        board.innerHTML = '';
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            const cell = document.createElement('div');
            cell.className = 'sudoku-cell';
            cell.dataset.row = i;
            cell.dataset.col = j;
            // åŒºå—è¾¹ç•ŒåŠ ç²—ï¼Œå†…éƒ¨åˆ†å‰²çº¿ä¸ºé«˜å¯¹æ¯”è“è‰²ï¼Œå¤–è¾¹æ¡†ä¸ºæ·±è“è‰²
            let style = '';
            // ä¸Šè¾¹
            if (i % regionRows === 0) {
              if (i === 0) style += 'border-top: 3px solid #1A365D;';
              else style += 'border-top: 3px solid #4299E1;';
            }
            // å·¦è¾¹
            if (j % regionCols === 0) {
              if (j === 0) style += 'border-left: 3px solid #1A365D;';
              else style += 'border-left: 3px solid #4299E1;';
            }
            // ä¸‹è¾¹
            if (i === size - 1) style += 'border-bottom: 3px solid #1A365D;';
            // å³è¾¹
            if (j === size - 1) style += 'border-right: 3px solid #1A365D;';
            cell.style = style;
            const value = this.gameBoard[i][j];
            if (value !== 0) {
              cell.textContent = value;
              if (this.originalBoard[i][j] !== 0) {
                cell.classList.add('origin');
              } else {
                cell.classList.add('user');
                cell.style.color = '#38A169'; // ç”¨æˆ·å¡«å…¥çš„æ•°å­—å§‹ç»ˆç»¿è‰²
              }
            }
            // ä»…å…è®¸ç”¨æˆ·ç‚¹å‡»ç©ºæ ¼è¿›è¡Œç¼–è¾‘
            if (this.originalBoard[i][j] === 0) {
              // console.log('add click event to cell', i, j, cell);
              cell.addEventListener('click', (e) => this.editCell(i, j, cell, e));
            }
            board.appendChild(cell);
          }
        }
        console.log('[renderBoard] æ¸²æŸ“ç»“æŸ');
      }

      editCell(row, col, cell, e) {
        console.log('editCell called', row, col, cell);
        if (this.isGameComplete) return;
        document.querySelectorAll('.sudoku-cell.selected').forEach(c => c.classList.remove('selected'));
        const oldInput = document.getElementById('sudoku-input-box');
        if (oldInput) {
          oldInput.blur();
        }
        cell.classList.add('selected');
        const input = document.createElement('input');
        input.type = 'number';
        input.id = 'sudoku-input-box';
        input.min = 1;
        input.max = this.gameBoard.length;
        input.value = this.gameBoard[row][col] || '';
        input.style.width = '100%';
        input.style.height = '100%';
        input.style.fontSize = '1.2em';
        input.style.textAlign = 'center';
        input.style.border = '2px solid #4299E1';
        input.style.borderRadius = '6px';
        input.style.outline = 'none';
        cell.innerHTML = '';
        cell.appendChild(input);
        input.focus();
        setTimeout(() => {
          console.log('input is focused:', document.activeElement === input);
        }, 100);
        input.select();
        input.addEventListener('input', () => {
          if (input.value.length > 2) input.value = input.value.slice(0, 2);
          if (parseInt(input.value) > this.gameBoard.length) input.value = this.gameBoard.length;
          if (parseInt(input.value) < 1) input.value = '';
        });
        input.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') {
            this.saveInputCell(row, col, cell, input.value);
            input.blur();
          } else if (ev.key === 'Escape') {
            input.blur();
          }
        });
        input.addEventListener('blur', () => {
          this.saveInputCell(row, col, cell, input.value);
        });
        input.addEventListener('mousedown', ev => ev.stopPropagation());
      }

      saveInputCell(row, col, cell, value) {
        // è¿˜åŸæ ¼å­å†…å®¹
        cell.classList.remove('selected');
        cell.innerHTML = '';
        let num = parseInt(value);
        if (!isNaN(num) && num >= 1 && num <= this.gameBoard.length) {
          this.fillNumberDirect(row, col, num);
        } else {
          this.fillNumberDirect(row, col, 0);
        }
      }

      checkAnswer() {
        const size = parseInt(this.currentMode.split('x')[0]);
        let hasErrors = false;
        // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯æ ‡è®°
        document.querySelectorAll('.sudoku-cell.error, .sudoku-cell.correct').forEach(cell => {
          cell.classList.remove('error', 'correct');
        });
        const errorCells = [];
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            // åªæ£€æŸ¥originalBoardä¸º0çš„æ ¼å­
            if (this.originalBoard[i][j] === 0) {
              const value = this.gameBoard[i][j];
              const cell = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
              if (value === 0) {
                // æœªå¡«å†™
                cell.classList.add('error');
                hasErrors = true;
                errorCells.push(cell);
              } else if (value !== this.getAnswerAt(i, j)) {
                // å¡«é”™
                cell.classList.add('error');
                hasErrors = true;
                errorCells.push(cell);
              } else {
                cell.classList.add('correct');
              }
            }
          }
        }
        if (hasErrors) {
          this.errorCount++;
          this.updateStats();
          // 1ç§’åè‡ªåŠ¨æ¶ˆå» error æ ·å¼
          setTimeout(() => {
            errorCells.forEach(cell => cell.classList.remove('error'));
          }, 1000);
          // æ£€æŸ¥é”™è¯¯æ¬¡æ•°ï¼Œ3æ¬¡åæ˜¾ç¤ºç­”æ¡ˆæŒ‰é’®
          if (!this.answerAvailable && this.errorCount >= 3) {
            this.answerAvailable = true;
            this.updateAnswerBtn();
            this.showInfo('ç­”æ¡ˆæœ‰è¯¯ï¼æ‚¨å·²ç´¯è®¡3æ¬¡æ£€æŸ¥é”™è¯¯ï¼Œç°åœ¨å¯ä»¥æŸ¥çœ‹ç­”æ¡ˆï¼', 'warn');
          } else {
            this.updateAnswerBtn();
            if (this.answerAvailable) {
              this.showInfo('ç­”æ¡ˆæœ‰è¯¯ï¼æ‚¨å¯ä»¥ç‚¹å‡»"æŸ¥çœ‹ç­”æ¡ˆ"æŒ‰é’®ç›´æ¥æŸ¥çœ‹ç­”æ¡ˆã€‚', 'warn');
            } else {
              const left = 3 - this.errorCount;
              this.showInfo(`ç­”æ¡ˆæœ‰è¯¯ï¼å†é”™${left}æ¬¡å³å¯è§£é”"æŸ¥çœ‹ç­”æ¡ˆ"æŒ‰é’®ã€‚`, 'warn');
            }
          }
        } else {
          this.showInfo('ç­”æ¡ˆå…¨éƒ¨æ­£ç¡®ï¼', 'success');
        }
      }

      // è·å–æ­£ç¡®ç­”æ¡ˆ
      getAnswerAt(row, col) {
        // ç”±äºoriginalBoardæ˜¯æŒ–ç©ºåçš„ï¼Œå®Œæ•´ç­”æ¡ˆå¯é€šè¿‡originalBoard+gameBoardçš„åˆå§‹ç”Ÿæˆè·å¾—
        // è¿™é‡Œç›´æ¥ç”¨originalBoardå’ŒgameBoardçš„åˆæˆï¼ˆä½†å®é™…ä¸Šåº”ä¿å­˜å®Œæ•´ç­”æ¡ˆï¼‰
        // ä½†ç›®å‰é€»è¾‘ä¸‹ï¼ŒoriginalBoardä¸º0çš„æ ¼å­ï¼ŒgameBoardçš„åˆå§‹å€¼å°±æ˜¯0ï¼Œ
        // ä½†æˆ‘ä»¬æ²¡æœ‰ä¿å­˜å®Œæ•´ç­”æ¡ˆï¼Œæ‰€ä»¥éœ€è¦åœ¨generateBoardæ—¶ä¿å­˜fullBoard
        // è¿™é‡Œè¡¥å……fullBoardçš„ä¿å­˜
        return this.fullBoard[row][col];
      }

      // showHint å†…éƒ¨
      showHint() {
        if (this.isGameComplete) return;
        if (this.hintCount <= 0) {
          this.showInfo('æ²¡æœ‰å‰©ä½™æç¤ºæ¬¡æ•°äº†ï¼', 'warn');
          return;
        }
        this.hintCount--;
        this.updateHintLabel();
        const size = parseInt(this.currentMode.split('x')[0]);
        const emptyCells = [];
        // æ‰¾åˆ°æ‰€æœ‰ç©ºæ ¼
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
            if (this.gameBoard[i][j] === 0) {
                emptyCells.push({ row: i, col: j });
            }
            }
        }
        if (emptyCells.length === 0) return;
        // éšæœºé€‰æ‹©ä¸€ä¸ªç©ºæ ¼ç»™å‡ºæç¤º
        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        const { row, col } = randomCell;
        // æ‰¾åˆ°æ­£ç¡®ç­”æ¡ˆ
        const num = this.getAnswerAt(row, col);
        this.gameBoard[row][col] = num;
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        cell.textContent = num;
        cell.classList.add('user');
        cell.style.background = '#E6FFFA';
        cell.style.color = '#38A169'; // ä¿è¯æç¤ºæ•°å­—ä¸ºç»¿è‰²
        // è®°å½•æ“ä½œå†å²
        this.userMoves.push({
            row,
            col,
            oldValue: 0,
            newValue: num
        });
        setTimeout(() => {
            cell.style.background = '';
        }, 1000);
        this.updateStats();
        this.checkCompletion();
        // æç¤ºå‰©ä½™æ¬¡æ•°æé†’
        const hintBtn = document.getElementById('hintBtn');
        hintBtn.title = `æ˜¾ç¤ºæç¤ºï¼ˆå‰©ä½™${this.hintCount}æ¬¡ï¼‰`;
        this.showInfo(`å·²ä½¿ç”¨æç¤ºï¼Œå‰©ä½™${this.hintCount}æ¬¡ã€‚`, 'success');
      }

      updateHintLabel() {
        const label = document.getElementById('hintCountLabel');
        label.textContent = `(å‰©${this.hintCount}æ¬¡)`;
      }

      showAnswer() {
        if (this.isGameComplete) return;
        if (!this.answerAvailable) {
          this.showInfo('è¯·å…ˆç´¯è®¡3æ¬¡æ£€æŸ¥é”™è¯¯åå†æŸ¥çœ‹ç­”æ¡ˆã€‚', 'info');
          return;
        }
        const size = parseInt(this.currentMode.split('x')[0]);
        // ä½¿ç”¨åŸå§‹å®Œæ•´ç­”æ¡ˆ
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.originalBoard[i][j] === 0) {
              this.gameBoard[i][j] = this.fullBoard[i][j];
              const cell = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
              cell.textContent = this.fullBoard[i][j];
              cell.classList.add('user');
              cell.style.color = '#9CA3AF'; // ç°è‰²
            }
          }
        }
        this.isGameComplete = true;
        this.updateStats();
        this.showInfo('å·²æ˜¾ç¤ºå…¨éƒ¨ç­”æ¡ˆã€‚', 'info');
      }

      updateAnswerBtn() {
        const answerBtn = document.getElementById('answerBtn');
        if (this.answerAvailable) {
          answerBtn.style.display = '';
        } else {
          answerBtn.style.display = 'none';
        }
      }

      undoMove() {
        if (this.isGameComplete) return;
        if (this.userMoves.length === 0) {
          this.showInfo('æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ', 'info');
          return;
        }
        const lastMove = this.userMoves.pop();
        const { row, col, oldValue } = lastMove;
        this.gameBoard[row][col] = oldValue;
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (oldValue === 0) {
          cell.textContent = '';
          cell.classList.remove('user', 'error', 'correct');
        } else {
          cell.textContent = oldValue;
          cell.classList.add('user');
          cell.classList.remove('error', 'correct');
        }
        this.updateStats();
        this.showInfo('å·²æˆåŠŸæ’¤é”€ä¸Šä¸€æ­¥', 'info');
      }

      restartGame() {
        // åªæ¸…ç©ºç”¨æˆ·å¡«å…¥çš„æ•°å­—ï¼Œä¿ç•™é¢˜ç›®
        const size = this.gameBoard.length;
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.originalBoard[i][j] === 0) {
              this.gameBoard[i][j] = 0;
            }
          }
        }
        this.userMoves = [];
        this.selectedCell = null;
        this.selectedNumber = null;
        this.errorCount = 0;
        this.isGameComplete = false;
        this.startTime = Date.now();
        this.renderBoard();
        this.updateStats();
        this.showInfo('å·²é‡ç½®æœ¬é¢˜ï¼Œè®¡æ—¶å’Œé”™è¯¯æ¬¡æ•°å·²æ¸…é›¶ã€‚', 'info');
      }

      nextQuestion() {
        this.currentQuestion++;
        this.userMoves = [];
        this.selectedCell = null;
        this.selectedNumber = null;
        this.errorCount = 0;
        this.hintCount = 3;
        this.answerAvailable = false;
        this.isGameComplete = false;
        // é‡ç½®è®¡æ—¶å™¨
        this.startTime = Date.now();
        this.generateBoard();
        this.renderBoard();
        this.updateUI();
        this.updateHintLabel();
        this.updateAnswerBtn();
        this.showInfo('', 'info');
        // éšè—æˆåŠŸæ¨¡æ€æ¡†
        document.getElementById('successModal').style.display = 'none';
      }

      changeMode(newMode) {
        console.log('[changeMode] åˆ‡æ¢æ¨¡å¼:', newMode);
        this.currentMode = newMode;
        this.currentQuestion = 1;
        this.userMoves = [];
        this.selectedCell = null;
        this.selectedNumber = null;
        this.errorCount = 0;
        this.isGameComplete = false;
        this.hintCount = 3;
        this.answerAvailable = false;
        // é‡ç½®è®¡æ—¶å™¨
        this.startTime = Date.now();
        this.generateBoard();
        this.renderBoard();
        this.updateUI();
        this.updateHintLabel();
        this.updateAnswerBtn();
        this.showInfo('', 'info');
      }

      checkCompletion() {
        const size = parseInt(this.currentMode.split('x')[0]);

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ ¼å­éƒ½å¡«æ»¡
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.gameBoard[i][j] === 0) return;
          }
        }

        // æ£€æŸ¥æ˜¯å¦æ­£ç¡®
        let isCorrect = true;
        for (let i = 0; i < size && isCorrect; i++) {
          for (let j = 0; j < size && isCorrect; j++) {
            const value = this.gameBoard[i][j];
            this.gameBoard[i][j] = 0;
            if (!this.isValidMove(this.gameBoard, i, j, value, size)) {
              isCorrect = false;
            }
            this.gameBoard[i][j] = value;
          }
        }

        if (isCorrect) {
          this.isGameComplete = true;
          this.showSuccessModal();
        }
      }

      showSuccessModal() {
        const modal = document.getElementById('successModal');
        const finalTime = document.getElementById('finalTime');

        finalTime.textContent = document.getElementById('timer').textContent;
        modal.style.display = 'flex';
      }

      updateStats() {
        const size = parseInt(this.currentMode.split('x')[0]);
        const totalCells = size * size;
        let filledCells = 0;

        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.gameBoard[i][j] !== 0) filledCells++;
          }
        }

        document.getElementById('filledCells').textContent = filledCells;
        document.getElementById('emptyCells').textContent = totalCells - filledCells;
        document.getElementById('errorCount').textContent = this.errorCount;
      }

      updateUI() {
        const modeDescriptions = {
          '4x4': { desc: '4Ã—4 ç®€å•æ¨¡å¼', difficulty: 'éš¾åº¦ï¼šå…¥é—¨ç®€å•' },
          '6x6': { desc: '6Ã—6 ä¸­ç­‰æ¨¡å¼', difficulty: 'éš¾åº¦ï¼šè¿›é˜¶ä¸­ç­‰' },
          '9x9': { desc: '9Ã—9 å›°éš¾æ¨¡å¼', difficulty: 'éš¾åº¦ï¼šä¸“å®¶å›°éš¾' }
        };

        const current = modeDescriptions[this.currentMode];
        document.getElementById('modeDesc').textContent = current.desc;
        document.getElementById('difficultyDesc').textContent = current.difficulty;
        document.getElementById('questionCounter').textContent =
          `ç¬¬ ${this.currentQuestion} é¢˜`;

        this.updateStats();
      }

      startTimer() {
        this.startTime = Date.now();
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
        }
        this.timerInterval = setInterval(() => {
          if (!this.isGameComplete) {
            const elapsed = Date.now() - this.startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timer').textContent = timeString;
          }
        }, 1000);
      }

      bindEvents() {
        // æ¨¡å¼é€‰æ‹©
        document.getElementById('modeSelect').addEventListener('change', (e) => {
          this.changeMode(e.target.value);
        });

        // åŠŸèƒ½æŒ‰é’®
        document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
        document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
        document.getElementById('checkBtn').addEventListener('click', () => this.checkAnswer());
        document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
        document.getElementById('answerBtn').addEventListener('click', () => this.showAnswer());
        document.getElementById('nextBtn').addEventListener('click', () => this.nextQuestion());

        // æˆåŠŸæ¨¡æ€æ¡†
        document.getElementById('nextQuestionBtn').addEventListener('click', () => this.nextQuestion());

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', this.handleKeydown);
      }

      handleKeydown(e) {
        console.log('keydown', e.key, this.selectedCell); // è°ƒè¯•è¾“å‡º
        if (this.isGameComplete) return;
        const size = parseInt(this.currentMode.split('x')[0]);
        if (this.selectedCell && this.originalBoard[this.selectedCell.row][this.selectedCell.col] === 0) {
          if (e.key >= '1' && e.key <= size.toString()) {
            this.fillNumberDirect(this.selectedCell.row, this.selectedCell.col, parseInt(e.key));
            document.querySelectorAll('.sudoku-cell.selected').forEach(cell => cell.classList.remove('selected'));
            this.selectedCell = null;
          } else if (e.key === 'Backspace' || e.key === 'Delete') {
            this.fillNumberDirect(this.selectedCell.row, this.selectedCell.col, 0);
            document.querySelectorAll('.sudoku-cell.selected').forEach(cell => cell.classList.remove('selected'));
            this.selectedCell = null;
          } else if (e.key === 'Escape') {
            document.querySelectorAll('.sudoku-cell.selected').forEach(cell => cell.classList.remove('selected'));
            this.selectedCell = null;
          }
        }
      }

      fillNumberDirect(row, col, num) {
        if (this.isGameComplete) return;
        // è®°å½•æ“ä½œå†å²
        this.userMoves.push({
          row,
          col,
          oldValue: this.gameBoard[row][col],
          newValue: num
        });
        this.gameBoard[row][col] = num;
        this.updateStats();
        this.checkCompletion();
        // ç«‹å³åˆ·æ–°è¯¥æ ¼æ˜¾ç¤º
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (num === 0) {
          cell.textContent = '';
          cell.classList.remove('user');
          cell.style.color = '';
        } else {
          cell.textContent = num;
          cell.classList.add('user');
          cell.style.color = '#4299E1';
        }
        cell.classList.remove('error', 'correct');
      }

      checkSudokuValid(board) {
        const size = board.length;
        let regionRows, regionCols;
        if (size === 4) { regionRows = regionCols = 2; }
        else if (size === 6) { regionRows = 2; regionCols = 3; }
        else if (size === 9) { regionRows = regionCols = 3; }
        // æ£€æŸ¥è¡Œ
        for (let i = 0; i < size; i++) {
          const rowSet = new Set();
          const colSet = new Set();
          for (let j = 0; j < size; j++) {
            if (rowSet.has(board[i][j])) return false;
            rowSet.add(board[i][j]);
            if (colSet.has(board[j][i])) return false;
            colSet.add(board[j][i]);
          }
        }
        // æ£€æŸ¥åŒºå—
        for (let r = 0; r < size; r += regionRows) {
          for (let c = 0; c < size; c += regionCols) {
            const blockSet = new Set();
            for (let i = 0; i < regionRows; i++) {
              for (let j = 0; j < regionCols; j++) {
                const val = board[r + i][c + j];
                if (blockSet.has(val)) return false;
                blockSet.add(val);
              }
            }
          }
        }
        return true;
      }

      showInfo(msg, type = 'info') {
        const info = document.getElementById('infoMessage');
        info.textContent = msg;
        info.className = 'info-message ' + type;
      }
    }

    // å¯åŠ¨æ¸¸æˆ
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded');
      new SudokuGame();
    });
  </script>
</body>
</html>