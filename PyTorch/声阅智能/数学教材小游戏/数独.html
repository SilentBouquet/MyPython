<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>数独挑战</title>
  <style>
    :root {
      --main-blue: #1A365D;
      --white: #FFFFFF;
      --accent-blue: #4299E1;
      --error-red: #E53E3E;
      --origin-gray: #2D3748;
      --user-black: #4A5568;
      --light-gray: #F7FAFC;
      --border-gray: #CBD5E1;
      --success-green: #38A169;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', 'PingFang SC', 'Hiragino Sans', Arial, sans-serif;
      background: linear-gradient(135deg, var(--main-blue) 0%, #2C5282 100%);
      color: var(--main-blue);
      min-height: 100vh;
      padding: 20px;
    }

    .sudoku-container {
      max-width: 900px;
      margin: 0 auto;
      background: var(--white);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(26,54,93,0.15);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* 顶部导航栏 */
    .navbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--main-blue);
      color: var(--white);
      padding: 20px 30px;
      position: relative;
    }

    .navbar::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-blue), #63B3ED);
    }

    .navbar-title {
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .navbar-center {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .navbar-select {
      background: var(--white);
      color: var(--main-blue);
      border: none;
      border-radius: 10px;
      padding: 8px 16px;
      font-size: 1.1rem;
      font-weight: 600;
      outline: none;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .navbar-select:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .navbar-counter {
      font-size: 1.1rem;
      font-weight: 600;
      background: var(--accent-blue);
      color: var(--white);
      border-radius: 12px;
      padding: 8px 16px;
      box-shadow: 0 2px 8px rgba(66,153,225,0.3);
    }

    /* 主游戏区域 */
    .main-area {
      display: flex;
      gap: 30px;
      padding: 30px;
      min-height: 600px;
    }

    .sudoku-board-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
      min-width: 340px;
    }

    .sudoku-board {
      display: grid;
      gap: 2px;
      background: var(--main-blue);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 8px 25px rgba(26,54,93,0.2);
      transition: all 0.3s ease;
    }

    .sudoku-board.mode-4x4 {
      grid-template-columns: repeat(4, 60px);
      grid-template-rows: repeat(4, 60px);
    }

    .sudoku-board.mode-6x6 {
      grid-template-columns: repeat(6, 50px);
      grid-template-rows: repeat(6, 50px);
    }

    .sudoku-board.mode-9x9 {
      grid-template-columns: repeat(9, 45px);
      grid-template-rows: repeat(9, 45px);
      min-width: 320px;
      max-width: 100vw;
      overflow-x: auto;
    }

    .sudoku-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: 600;
      background: var(--white);
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      border-radius: 4px;
      position: relative;
    }

    .sudoku-cell:hover:not(.origin) {
      background: #EBF8FF;
      transform: scale(1.05);
    }

    .sudoku-cell.origin {
      color: var(--origin-gray);
      font-weight: 700;
      background: var(--light-gray);
      cursor: default;
    }

    .sudoku-cell.origin:hover {
      transform: none;
      background: var(--light-gray);
    }

    .sudoku-cell.user {
      color: var(--accent-blue);
      font-weight: 600;
    }

    .sudoku-cell.selected {
      background: #EBF8FF;
      box-shadow: 0 0 0 3px var(--accent-blue);
      transform: scale(1.05);
    }

    .sudoku-cell.error {
      background: #FFF5F5;
      color: var(--error-red);
      box-shadow: 0 0 0 3px var(--error-red);
    }

    .sudoku-cell.correct {
      background: #F0FFF4;
      color: var(--success-green);
      box-shadow: 0 0 0 3px var(--success-green);
    }

    /* 控制面板 */
    .control-panel {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      width: 100%;
      gap: 24px;
    }

    .number-select {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .number-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--light-gray);
      color: var(--main-blue);
      font-size: 1.3rem;
      font-weight: 700;
      border: none;
      outline: none;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .number-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }

    .number-btn.selected {
      background: var(--accent-blue);
      color: var(--white);
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(66,153,225,0.4);
    }

    .number-btn.delete {
      background: var(--error-red);
      color: var(--white);
      font-size: 1.5rem;
    }

    .number-btn.delete:hover {
      background: #C53030;
    }

    /* 功能按钮区 */
    .function-btns {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 18px 18px;
      width: 100%;
    }

    .func-btn {
      background: var(--accent-blue);
      color: var(--white);
      border: none;
      border-radius: 12px;
      padding: 10px 16px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(66,153,225,0.3);
      white-space: nowrap;
    }

    .func-btn:hover {
      background: #2B6CB0;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(66,153,225,0.4);
    }

    .func-btn:active {
      transform: translateY(0);
    }

    /* 右侧面板 */
    .side-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      background: var(--light-gray);
      border-radius: 16px;
      padding: 25px;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }

    .mode-desc {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent-blue);
      text-align: center;
      padding: 15px;
      background: var(--white);
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .difficulty {
      color: #718096;
      font-size: 1rem;
      font-weight: 500;
      text-align: center;
    }

    .hint {
      color: var(--main-blue);
      font-size: 0.95rem;
      line-height: 1.5;
      background: var(--white);
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid var(--accent-blue);
    }

    .timer {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--main-blue);
      text-align: center;
      background: var(--white);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-family: 'Courier New', monospace;
    }

    .stats {
      background: var(--white);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    .stats-label {
      color: #718096;
    }

    .stats-value {
      font-weight: 600;
      color: var(--main-blue);
    }

    /* 成功提示 */
    .success-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .success-content {
      background: var(--white);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      max-width: 400px;
    }

    .success-title {
      font-size: 2rem;
      font-weight: 700;
      color: var(--success-green);
      margin-bottom: 15px;
    }

    .success-text {
      font-size: 1.1rem;
      color: var(--main-blue);
      margin-bottom: 25px;
    }

    .success-btn {
      background: var(--accent-blue);
      color: var(--white);
      border: none;
      border-radius: 12px;
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .success-btn:hover {
      background: #2B6CB0;
      transform: translateY(-2px);
    }

    /* 响应式设计 */
    @media (max-width: 768px) {
      .main-area {
        flex-direction: column;
        gap: 20px;
        padding: 20px;
      }

      .side-panel {
        min-width: 0;
        width: 100%;
      }

      .control-panel {
        flex-direction: column;
        gap: 15px;
      }

      .function-btns {
        justify-content: center;
      }

      .navbar {
        padding: 15px 20px;
      }

      .navbar-title {
        font-size: 1.4rem;
      }

      .sudoku-board.mode-4x4 {
        grid-template-columns: repeat(4, 50px);
        grid-template-rows: repeat(4, 50px);
      }

      .sudoku-board.mode-6x6 {
        grid-template-columns: repeat(6, 42px);
        grid-template-rows: repeat(6, 42px);
      }

      .sudoku-board.mode-9x9 {
        grid-template-columns: repeat(9, 36px);
        grid-template-rows: repeat(9, 36px);
        font-size: 0.95rem;
      }

      .sudoku-board-panel {
        min-width: 0;
      }
    }

    .info-message {
      margin-top: 16px;
      text-align: center;
      font-size: 1.08rem;
      font-weight: 600;
      min-height: 1.5em;
      width: 100%;
      border: none;
      background: none;
      box-shadow: none;
    }
    .info-message.info { color: #3182ce; }
    .info-message.success { color: #38A169; }
    .info-message.warn { color: #E53E3E; }
  </style>
</head>
<body>
  <div class="sudoku-container">
    <!-- 顶部导航栏 -->
    <div class="navbar">
      <div class="navbar-title">🧩 数独挑战</div>
      <div class="navbar-center">
        <select class="navbar-select" id="modeSelect">
          <option value="4x4">4×4 简单</option>
          <option value="6x6">6×6 中等</option>
          <option value="9x9">9×9 困难</option>
        </select>
      </div>
      <div class="navbar-counter" id="questionCounter">第 1 题</div>
    </div>

    <!-- 主游戏区域 -->
    <div class="main-area">
      <!-- 数独网格和控制面板 -->
      <div class="sudoku-board-panel">
        <div class="sudoku-board mode-4x4" id="sudokuBoard">
          <!-- 动态生成格子 -->
        </div>

        <!-- 控制面板 -->
        <div class="control-panel">
          <div class="function-btns">
            <button class="func-btn" id="restartBtn" title="重新开始">🔄 重玩</button>
            <button class="func-btn" id="undoBtn" title="撤销上一步">↶ 撤销</button>
            <button class="func-btn" id="checkBtn" title="检查答案">✓ 检查</button>
            <button class="func-btn" id="hintBtn" title="显示提示">💡 提示 <span id="hintCountLabel" style="font-size:0.95em;color:#fff;margin-left:4px;"></span></button>
            <button class="func-btn" id="answerBtn" title="显示答案" style="display:none;">👁 答案</button>
            <button class="func-btn" id="nextBtn" title="下一题">下一题 →</button>
          </div>
          <div id="infoMessage" class="info-message"></div>
        </div>
      </div>

      <!-- 右侧面板 -->
      <div class="side-panel">
        <div class="mode-desc" id="modeDesc">4×4 简单模式</div>
        <div class="difficulty" id="difficultyDesc">难度：入门简单</div>
        <div class="hint" id="gameHint">
          💡 提示：每行、每列和每个区域都不能有重复数字。点击空格选择，然后点击数字填入。
        </div>
        <div class="timer" id="timer">00:00:00</div>
        <div class="stats">
          <div class="stats-item">
            <span class="stats-label">已填格数：</span>
            <span class="stats-value" id="filledCells">0</span>
          </div>
          <div class="stats-item">
            <span class="stats-label">剩余空格：</span>
            <span class="stats-value" id="emptyCells">0</span>
          </div>
          <div class="stats-item">
            <span class="stats-label">错误次数：</span>
            <span class="stats-value" id="errorCount">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 成功提示模态框 -->
  <div class="success-modal" id="successModal">
    <div class="success-content">
      <div class="success-title">🎉 恭喜完成！</div>
      <div class="success-text" id="successText">
        您用时 <span id="finalTime">00:00:00</span> 完成了这道数独题！
      </div>
      <button class="success-btn" id="nextQuestionBtn">下一题</button>
    </div>
  </div>

  <script>
    console.log('script loaded'); // 检查脚本是否加载
    class SudokuGame {
      constructor() {
        console.log('SudokuGame constructor');
        this.currentMode = '4x4';
        this.currentQuestion = 1;
        this.totalQuestions = 10;
        this.selectedCell = null;
        this.selectedNumber = null;
        this.gameBoard = [];
        this.originalBoard = [];
        this.userMoves = [];
        this.startTime = null;
        this.timerInterval = null;
        this.errorCount = 0;
        this.isGameComplete = false;
        this.hintCount = 3; // 初始提示次数
        this.answerAvailable = false; // 答案按钮是否可见
        this.handleKeydown = this.handleKeydown.bind(this);
        this.initializeGame();
        this.bindEvents();
        this.startTimer();
      }

      initializeGame() {
        console.log('initializeGame');
        this.generateBoard();
        this.renderBoard();
        this.hintCount = 3;
        this.answerAvailable = false;
        this.updateHintLabel();
        this.updateAnswerBtn();
      }

      generateBoard() {
        const size = parseInt(this.currentMode.split('x')[0]);
        console.log('[generateBoard] 当前模式:', this.currentMode, 'size:', size);
        let valid = false;
        let tryCount = 0;
        while (!valid && tryCount < 20) {
            // 1. 生成完整盘面
            const fullBoard = this.generateCompleteSudoku(size);
            console.log('[generateBoard] fullBoard:', fullBoard);
            // 2. 挖空，得到初始盘面（传递副本）
            const puzzleBoard = JSON.parse(JSON.stringify(fullBoard));
            this.removeNumbers(puzzleBoard, size);
            // 3. 唯一性校验
            valid = this.checkSudokuValid(fullBoard);
            if (valid) {
                this.fullBoard = JSON.parse(JSON.stringify(fullBoard));
                this.gameBoard = JSON.parse(JSON.stringify(puzzleBoard));
                this.originalBoard = JSON.parse(JSON.stringify(puzzleBoard));
            }
            tryCount++;
        }
        if (!valid) {
            throw new Error('无法生成合法的数独盘面，请检查模板或生成逻辑！');
        }
        console.log('[generateBoard] 生成完成，gameBoard:', this.gameBoard, 'originalBoard:', this.originalBoard, 'fullBoard:', this.fullBoard);
    }

      generateCompleteSudoku(size) {
        console.log('[generateCompleteSudoku] size:', size);
        // 修复二维数组初始化，确保每一行都是独立的数组
        const board = [];
        for (let i = 0; i < size; i++) {
          board.push(new Array(size).fill(0));
        }
        // 使用更简单但有效的生成方法
        if (size === 4) {
          console.log('调用generateSimple4x4');
          this.generateSimple4x4(board);
        } else if (size === 6) {
          console.log('调用generateSimple6x6');
          this.generateSimple6x6(board);
        } else if (size === 9) {
          console.log('调用generateSimple9x9');
          this.generateSimple9x9(board);
        }
        console.log('[generateCompleteSudoku] 生成后board:', board);
        return board;
      }

      generateSimple4x4(board) {
        // 预设一个有效的4x4数独模板
        const templates = [
          [
            [1, 2, 3, 4],
            [3, 4, 1, 2],
            [2, 1, 4, 3],
            [4, 3, 2, 1]
          ],
          [
            [2, 1, 4, 3],
            [4, 3, 2, 1],
            [1, 2, 3, 4],
            [3, 4, 1, 2]
          ],
          [
            [3, 4, 1, 2],
            [1, 2, 3, 4],
            [4, 3, 2, 1],
            [2, 1, 4, 3]
          ]
        ];

        const template = templates[Math.floor(Math.random() * templates.length)];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            board[i][j] = template[i][j];
          }
        }

        // 随机打乱行和列
        this.shuffleBoard4x4(board);
      }

      generateSimple6x6(board) {
        // 预设一个有效的6x6数独模板
        const template = [
          [1, 2, 3, 4, 5, 6],
          [4, 5, 6, 1, 2, 3],
          [2, 3, 1, 6, 4, 5],
          [5, 6, 4, 3, 1, 2],
          [3, 1, 2, 5, 6, 4],
          [6, 4, 5, 2, 3, 1]
        ];

        for (let i = 0; i < 6; i++) {
          for (let j = 0; j < 6; j++) {
            board[i][j] = template[i][j];
          }
        }

        this.shuffleBoard6x6(board);
      }

      generateSimple9x9(board) {
        // 经典9x9数独模板
        const template = [
          [5,3,4,6,7,8,9,1,2],
          [6,7,2,1,9,5,3,4,8],
          [1,9,8,3,4,2,5,6,7],
          [8,5,9,7,6,1,4,2,3],
          [4,2,6,8,5,3,7,9,1],
          [7,1,3,9,2,4,8,5,6],
          [9,6,1,5,3,7,2,8,4],
          [2,8,7,4,1,9,6,3,5],
          [3,4,5,2,8,6,1,7,9]
        ];
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            board[i][j] = template[i][j];
          }
        }
        this.shuffleBoard9x9(board);
      }

      shuffleBoard4x4(board) {
        // 随机交换行（在同一个2x2区域内）
        if (Math.random() > 0.5) {
          [board[0], board[1]] = [board[1], board[0]];
        }
        if (Math.random() > 0.5) {
          [board[2], board[3]] = [board[3], board[2]];
        }

        // 随机交换列（在同一个2x2区域内）
        if (Math.random() > 0.5) {
          for (let i = 0; i < 4; i++) {
            [board[i][0], board[i][1]] = [board[i][1], board[i][0]];
          }
        }
        if (Math.random() > 0.5) {
          for (let i = 0; i < 4; i++) {
            [board[i][2], board[i][3]] = [board[i][3], board[i][2]];
          }
        }
      }

      shuffleBoard6x6(board) {
        // 随机交换行（在同一个2x3区域内）
        if (Math.random() > 0.5) {
          [board[0], board[1]] = [board[1], board[0]];
        }
        if (Math.random() > 0.5) {
          [board[2], board[3]] = [board[3], board[2]];
        }
        if (Math.random() > 0.5) {
          [board[4], board[5]] = [board[5], board[4]];
        }

        // 随机交换列
        for (let group = 0; group < 2; group++) {
          const start = group * 3;
          if (Math.random() > 0.5) {
            for (let i = 0; i < 6; i++) {
              [board[i][start], board[i][start + 1]] = [board[i][start + 1], board[i][start]];
            }
          }
          if (Math.random() > 0.5) {
            for (let i = 0; i < 6; i++) {
              [board[i][start + 1], board[i][start + 2]] = [board[i][start + 2], board[i][start + 1]];
            }
          }
        }
      }

      shuffleBoard9x9(board) {
            // 行组内交换
            for (let g = 0; g < 3; g++) {
                const rows = [g * 3, g * 3 + 1, g * 3 + 2];
                if (Math.random() > 0.5) [board[rows[0]], board[rows[1]]] = [board[rows[1]], board[rows[0]]];
                if (Math.random() > 0.5) [board[rows[1]], board[rows[2]]] = [board[rows[2]], board[rows[1]]];
            }
            // 行组整体交换
            if (Math.random() > 0.5) {
                [board[0], board[3], board[6]] = [board[6], board[0], board[3]];
                [board[1], board[4], board[7]] = [board[7], board[1], board[4]];
                [board[2], board[5], board[8]] = [board[8], board[2], board[5]];
            }
            // 列组内交换
            for (let g = 0; g < 3; g++) {
                const cols = [g * 3, g * 3 + 1, g * 3 + 2];
                if (Math.random() > 0.5) for (let i = 0; i < 9; i++) [board[i][cols[0]], board[i][cols[1]]] = [board[i][cols[1]], board[i][cols[0]]];
                if (Math.random() > 0.5) for (let i = 0; i < 9; i++) [board[i][cols[1]], board[i][cols[2]]] = [board[i][cols[2]], board[i][cols[1]]];
            }
            // 列组整体交换
            if (Math.random() > 0.5) {
                for (let i = 0; i < 9; i++) {
                [board[i][0], board[i][3], board[i][6]] = [board[i][6], board[i][0], board[i][3]];
                [board[i][1], board[i][4], board[i][7]] = [board[i][7], board[i][1], board[i][4]];
                [board[i][2], board[i][5], board[i][8]] = [board[i][8], board[i][2], board[i][5]];
                }
            }
    }

      isValidMove(board, row, col, num, size) {
        // 检查行
        for (let x = 0; x < size; x++) {
          if (x !== col && board[row][x] === num) return false;
        }

        // 检查列
        for (let x = 0; x < size; x++) {
          if (x !== row && board[x][col] === num) return false;
        }

        // 检查区域
        let regionRows, regionCols;
        if (size === 4) {
          regionRows = regionCols = 2;
        } else if (size === 6) {
          regionRows = 2;
          regionCols = 3;
        } else if (size === 9) {
          regionRows = 3;
          regionCols = 3;
        }

        const startRow = Math.floor(row / regionRows) * regionRows;
        const startCol = Math.floor(col / regionCols) * regionCols;

        for (let i = 0; i < regionRows; i++) {
          for (let j = 0; j < regionCols; j++) {
            const checkRow = i + startRow;
            const checkCol = j + startCol;
            if (checkRow !== row && checkCol !== col && board[checkRow][checkCol] === num) {
              return false;
            }
          }
        }

        return true;
      }

      removeNumbers(board, size) {
        const totalCells = size * size;
        let cellsToRemove;
        switch(this.currentMode) {
          case '4x4': cellsToRemove = Math.floor(totalCells * 0.5); break;
          case '6x6': cellsToRemove = Math.floor(totalCells * 0.55); break;
          case '9x9': cellsToRemove = Math.floor(totalCells * 0.6); break;
        }
        const positions = [];
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            positions.push([i, j]);
          }
        }
        this.shuffleArray(positions);
        for (let i = 0; i < cellsToRemove; i++) {
          const [row, col] = positions[i];
          board[row][col] = 0;
        }
      }

      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      renderBoard() {
        console.log('[renderBoard] 渲染盘面，当前模式:', this.currentMode, 'gameBoard:', this.gameBoard);
        const board = document.getElementById('sudokuBoard');
        console.log('sudokuBoard dom:', board);
        const size = parseInt(this.currentMode.split('x')[0]);
        let regionRows = 2, regionCols = 2;
        if (size === 6) { regionRows = 2; regionCols = 3; }
        else if (size === 9) { regionRows = 3; regionCols = 3; }
        board.className = `sudoku-board mode-${this.currentMode}`;
        board.innerHTML = '';
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            const cell = document.createElement('div');
            cell.className = 'sudoku-cell';
            cell.dataset.row = i;
            cell.dataset.col = j;
            // 区块边界加粗，内部分割线为高对比蓝色，外边框为深蓝色
            let style = '';
            // 上边
            if (i % regionRows === 0) {
              if (i === 0) style += 'border-top: 3px solid #1A365D;';
              else style += 'border-top: 3px solid #4299E1;';
            }
            // 左边
            if (j % regionCols === 0) {
              if (j === 0) style += 'border-left: 3px solid #1A365D;';
              else style += 'border-left: 3px solid #4299E1;';
            }
            // 下边
            if (i === size - 1) style += 'border-bottom: 3px solid #1A365D;';
            // 右边
            if (j === size - 1) style += 'border-right: 3px solid #1A365D;';
            cell.style = style;
            const value = this.gameBoard[i][j];
            if (value !== 0) {
              cell.textContent = value;
              if (this.originalBoard[i][j] !== 0) {
                cell.classList.add('origin');
              } else {
                cell.classList.add('user');
                cell.style.color = '#38A169'; // 用户填入的数字始终绿色
              }
            }
            // 仅允许用户点击空格进行编辑
            if (this.originalBoard[i][j] === 0) {
              // console.log('add click event to cell', i, j, cell);
              cell.addEventListener('click', (e) => this.editCell(i, j, cell, e));
            }
            board.appendChild(cell);
          }
        }
        console.log('[renderBoard] 渲染结束');
      }

      editCell(row, col, cell, e) {
        console.log('editCell called', row, col, cell);
        if (this.isGameComplete) return;
        document.querySelectorAll('.sudoku-cell.selected').forEach(c => c.classList.remove('selected'));
        const oldInput = document.getElementById('sudoku-input-box');
        if (oldInput) {
          oldInput.blur();
        }
        cell.classList.add('selected');
        const input = document.createElement('input');
        input.type = 'number';
        input.id = 'sudoku-input-box';
        input.min = 1;
        input.max = this.gameBoard.length;
        input.value = this.gameBoard[row][col] || '';
        input.style.width = '100%';
        input.style.height = '100%';
        input.style.fontSize = '1.2em';
        input.style.textAlign = 'center';
        input.style.border = '2px solid #4299E1';
        input.style.borderRadius = '6px';
        input.style.outline = 'none';
        cell.innerHTML = '';
        cell.appendChild(input);
        input.focus();
        setTimeout(() => {
          console.log('input is focused:', document.activeElement === input);
        }, 100);
        input.select();
        input.addEventListener('input', () => {
          if (input.value.length > 2) input.value = input.value.slice(0, 2);
          if (parseInt(input.value) > this.gameBoard.length) input.value = this.gameBoard.length;
          if (parseInt(input.value) < 1) input.value = '';
        });
        input.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') {
            this.saveInputCell(row, col, cell, input.value);
            input.blur();
          } else if (ev.key === 'Escape') {
            input.blur();
          }
        });
        input.addEventListener('blur', () => {
          this.saveInputCell(row, col, cell, input.value);
        });
        input.addEventListener('mousedown', ev => ev.stopPropagation());
      }

      saveInputCell(row, col, cell, value) {
        // 还原格子内容
        cell.classList.remove('selected');
        cell.innerHTML = '';
        let num = parseInt(value);
        if (!isNaN(num) && num >= 1 && num <= this.gameBoard.length) {
          this.fillNumberDirect(row, col, num);
        } else {
          this.fillNumberDirect(row, col, 0);
        }
      }

      checkAnswer() {
        const size = parseInt(this.currentMode.split('x')[0]);
        let hasErrors = false;
        // 清除之前的错误标记
        document.querySelectorAll('.sudoku-cell.error, .sudoku-cell.correct').forEach(cell => {
          cell.classList.remove('error', 'correct');
        });
        const errorCells = [];
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            // 只检查originalBoard为0的格子
            if (this.originalBoard[i][j] === 0) {
              const value = this.gameBoard[i][j];
              const cell = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
              if (value === 0) {
                // 未填写
                cell.classList.add('error');
                hasErrors = true;
                errorCells.push(cell);
              } else if (value !== this.getAnswerAt(i, j)) {
                // 填错
                cell.classList.add('error');
                hasErrors = true;
                errorCells.push(cell);
              } else {
                cell.classList.add('correct');
              }
            }
          }
        }
        if (hasErrors) {
          this.errorCount++;
          this.updateStats();
          // 1秒后自动消去 error 样式
          setTimeout(() => {
            errorCells.forEach(cell => cell.classList.remove('error'));
          }, 1000);
          // 检查错误次数，3次后显示答案按钮
          if (!this.answerAvailable && this.errorCount >= 3) {
            this.answerAvailable = true;
            this.updateAnswerBtn();
            this.showInfo('答案有误！您已累计3次检查错误，现在可以查看答案！', 'warn');
          } else {
            this.updateAnswerBtn();
            if (this.answerAvailable) {
              this.showInfo('答案有误！您可以点击"查看答案"按钮直接查看答案。', 'warn');
            } else {
              const left = 3 - this.errorCount;
              this.showInfo(`答案有误！再错${left}次即可解锁"查看答案"按钮。`, 'warn');
            }
          }
        } else {
          this.showInfo('答案全部正确！', 'success');
        }
      }

      // 获取正确答案
      getAnswerAt(row, col) {
        // 由于originalBoard是挖空后的，完整答案可通过originalBoard+gameBoard的初始生成获得
        // 这里直接用originalBoard和gameBoard的合成（但实际上应保存完整答案）
        // 但目前逻辑下，originalBoard为0的格子，gameBoard的初始值就是0，
        // 但我们没有保存完整答案，所以需要在generateBoard时保存fullBoard
        // 这里补充fullBoard的保存
        return this.fullBoard[row][col];
      }

      // showHint 内部
      showHint() {
        if (this.isGameComplete) return;
        if (this.hintCount <= 0) {
          this.showInfo('没有剩余提示次数了！', 'warn');
          return;
        }
        this.hintCount--;
        this.updateHintLabel();
        const size = parseInt(this.currentMode.split('x')[0]);
        const emptyCells = [];
        // 找到所有空格
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
            if (this.gameBoard[i][j] === 0) {
                emptyCells.push({ row: i, col: j });
            }
            }
        }
        if (emptyCells.length === 0) return;
        // 随机选择一个空格给出提示
        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        const { row, col } = randomCell;
        // 找到正确答案
        const num = this.getAnswerAt(row, col);
        this.gameBoard[row][col] = num;
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        cell.textContent = num;
        cell.classList.add('user');
        cell.style.background = '#E6FFFA';
        cell.style.color = '#38A169'; // 保证提示数字为绿色
        // 记录操作历史
        this.userMoves.push({
            row,
            col,
            oldValue: 0,
            newValue: num
        });
        setTimeout(() => {
            cell.style.background = '';
        }, 1000);
        this.updateStats();
        this.checkCompletion();
        // 提示剩余次数提醒
        const hintBtn = document.getElementById('hintBtn');
        hintBtn.title = `显示提示（剩余${this.hintCount}次）`;
        this.showInfo(`已使用提示，剩余${this.hintCount}次。`, 'success');
      }

      updateHintLabel() {
        const label = document.getElementById('hintCountLabel');
        label.textContent = `(剩${this.hintCount}次)`;
      }

      showAnswer() {
        if (this.isGameComplete) return;
        if (!this.answerAvailable) {
          this.showInfo('请先累计3次检查错误后再查看答案。', 'info');
          return;
        }
        const size = parseInt(this.currentMode.split('x')[0]);
        // 使用原始完整答案
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.originalBoard[i][j] === 0) {
              this.gameBoard[i][j] = this.fullBoard[i][j];
              const cell = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
              cell.textContent = this.fullBoard[i][j];
              cell.classList.add('user');
              cell.style.color = '#9CA3AF'; // 灰色
            }
          }
        }
        this.isGameComplete = true;
        this.updateStats();
        this.showInfo('已显示全部答案。', 'info');
      }

      updateAnswerBtn() {
        const answerBtn = document.getElementById('answerBtn');
        if (this.answerAvailable) {
          answerBtn.style.display = '';
        } else {
          answerBtn.style.display = 'none';
        }
      }

      undoMove() {
        if (this.isGameComplete) return;
        if (this.userMoves.length === 0) {
          this.showInfo('没有可撤销的操作', 'info');
          return;
        }
        const lastMove = this.userMoves.pop();
        const { row, col, oldValue } = lastMove;
        this.gameBoard[row][col] = oldValue;
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (oldValue === 0) {
          cell.textContent = '';
          cell.classList.remove('user', 'error', 'correct');
        } else {
          cell.textContent = oldValue;
          cell.classList.add('user');
          cell.classList.remove('error', 'correct');
        }
        this.updateStats();
        this.showInfo('已成功撤销上一步', 'info');
      }

      restartGame() {
        // 只清空用户填入的数字，保留题目
        const size = this.gameBoard.length;
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.originalBoard[i][j] === 0) {
              this.gameBoard[i][j] = 0;
            }
          }
        }
        this.userMoves = [];
        this.selectedCell = null;
        this.selectedNumber = null;
        this.errorCount = 0;
        this.isGameComplete = false;
        this.startTime = Date.now();
        this.renderBoard();
        this.updateStats();
        this.showInfo('已重置本题，计时和错误次数已清零。', 'info');
      }

      nextQuestion() {
        this.currentQuestion++;
        this.userMoves = [];
        this.selectedCell = null;
        this.selectedNumber = null;
        this.errorCount = 0;
        this.hintCount = 3;
        this.answerAvailable = false;
        this.isGameComplete = false;
        // 重置计时器
        this.startTime = Date.now();
        this.generateBoard();
        this.renderBoard();
        this.updateUI();
        this.updateHintLabel();
        this.updateAnswerBtn();
        this.showInfo('', 'info');
        // 隐藏成功模态框
        document.getElementById('successModal').style.display = 'none';
      }

      changeMode(newMode) {
        console.log('[changeMode] 切换模式:', newMode);
        this.currentMode = newMode;
        this.currentQuestion = 1;
        this.userMoves = [];
        this.selectedCell = null;
        this.selectedNumber = null;
        this.errorCount = 0;
        this.isGameComplete = false;
        this.hintCount = 3;
        this.answerAvailable = false;
        // 重置计时器
        this.startTime = Date.now();
        this.generateBoard();
        this.renderBoard();
        this.updateUI();
        this.updateHintLabel();
        this.updateAnswerBtn();
        this.showInfo('', 'info');
      }

      checkCompletion() {
        const size = parseInt(this.currentMode.split('x')[0]);

        // 检查是否所有格子都填满
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.gameBoard[i][j] === 0) return;
          }
        }

        // 检查是否正确
        let isCorrect = true;
        for (let i = 0; i < size && isCorrect; i++) {
          for (let j = 0; j < size && isCorrect; j++) {
            const value = this.gameBoard[i][j];
            this.gameBoard[i][j] = 0;
            if (!this.isValidMove(this.gameBoard, i, j, value, size)) {
              isCorrect = false;
            }
            this.gameBoard[i][j] = value;
          }
        }

        if (isCorrect) {
          this.isGameComplete = true;
          this.showSuccessModal();
        }
      }

      showSuccessModal() {
        const modal = document.getElementById('successModal');
        const finalTime = document.getElementById('finalTime');

        finalTime.textContent = document.getElementById('timer').textContent;
        modal.style.display = 'flex';
      }

      updateStats() {
        const size = parseInt(this.currentMode.split('x')[0]);
        const totalCells = size * size;
        let filledCells = 0;

        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            if (this.gameBoard[i][j] !== 0) filledCells++;
          }
        }

        document.getElementById('filledCells').textContent = filledCells;
        document.getElementById('emptyCells').textContent = totalCells - filledCells;
        document.getElementById('errorCount').textContent = this.errorCount;
      }

      updateUI() {
        const modeDescriptions = {
          '4x4': { desc: '4×4 简单模式', difficulty: '难度：入门简单' },
          '6x6': { desc: '6×6 中等模式', difficulty: '难度：进阶中等' },
          '9x9': { desc: '9×9 困难模式', difficulty: '难度：专家困难' }
        };

        const current = modeDescriptions[this.currentMode];
        document.getElementById('modeDesc').textContent = current.desc;
        document.getElementById('difficultyDesc').textContent = current.difficulty;
        document.getElementById('questionCounter').textContent =
          `第 ${this.currentQuestion} 题`;

        this.updateStats();
      }

      startTimer() {
        this.startTime = Date.now();
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
        }
        this.timerInterval = setInterval(() => {
          if (!this.isGameComplete) {
            const elapsed = Date.now() - this.startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timer').textContent = timeString;
          }
        }, 1000);
      }

      bindEvents() {
        // 模式选择
        document.getElementById('modeSelect').addEventListener('change', (e) => {
          this.changeMode(e.target.value);
        });

        // 功能按钮
        document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
        document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
        document.getElementById('checkBtn').addEventListener('click', () => this.checkAnswer());
        document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
        document.getElementById('answerBtn').addEventListener('click', () => this.showAnswer());
        document.getElementById('nextBtn').addEventListener('click', () => this.nextQuestion());

        // 成功模态框
        document.getElementById('nextQuestionBtn').addEventListener('click', () => this.nextQuestion());

        // 键盘事件
        document.addEventListener('keydown', this.handleKeydown);
      }

      handleKeydown(e) {
        console.log('keydown', e.key, this.selectedCell); // 调试输出
        if (this.isGameComplete) return;
        const size = parseInt(this.currentMode.split('x')[0]);
        if (this.selectedCell && this.originalBoard[this.selectedCell.row][this.selectedCell.col] === 0) {
          if (e.key >= '1' && e.key <= size.toString()) {
            this.fillNumberDirect(this.selectedCell.row, this.selectedCell.col, parseInt(e.key));
            document.querySelectorAll('.sudoku-cell.selected').forEach(cell => cell.classList.remove('selected'));
            this.selectedCell = null;
          } else if (e.key === 'Backspace' || e.key === 'Delete') {
            this.fillNumberDirect(this.selectedCell.row, this.selectedCell.col, 0);
            document.querySelectorAll('.sudoku-cell.selected').forEach(cell => cell.classList.remove('selected'));
            this.selectedCell = null;
          } else if (e.key === 'Escape') {
            document.querySelectorAll('.sudoku-cell.selected').forEach(cell => cell.classList.remove('selected'));
            this.selectedCell = null;
          }
        }
      }

      fillNumberDirect(row, col, num) {
        if (this.isGameComplete) return;
        // 记录操作历史
        this.userMoves.push({
          row,
          col,
          oldValue: this.gameBoard[row][col],
          newValue: num
        });
        this.gameBoard[row][col] = num;
        this.updateStats();
        this.checkCompletion();
        // 立即刷新该格显示
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (num === 0) {
          cell.textContent = '';
          cell.classList.remove('user');
          cell.style.color = '';
        } else {
          cell.textContent = num;
          cell.classList.add('user');
          cell.style.color = '#4299E1';
        }
        cell.classList.remove('error', 'correct');
      }

      checkSudokuValid(board) {
        const size = board.length;
        let regionRows, regionCols;
        if (size === 4) { regionRows = regionCols = 2; }
        else if (size === 6) { regionRows = 2; regionCols = 3; }
        else if (size === 9) { regionRows = regionCols = 3; }
        // 检查行
        for (let i = 0; i < size; i++) {
          const rowSet = new Set();
          const colSet = new Set();
          for (let j = 0; j < size; j++) {
            if (rowSet.has(board[i][j])) return false;
            rowSet.add(board[i][j]);
            if (colSet.has(board[j][i])) return false;
            colSet.add(board[j][i]);
          }
        }
        // 检查区块
        for (let r = 0; r < size; r += regionRows) {
          for (let c = 0; c < size; c += regionCols) {
            const blockSet = new Set();
            for (let i = 0; i < regionRows; i++) {
              for (let j = 0; j < regionCols; j++) {
                const val = board[r + i][c + j];
                if (blockSet.has(val)) return false;
                blockSet.add(val);
              }
            }
          }
        }
        return true;
      }

      showInfo(msg, type = 'info') {
        const info = document.getElementById('infoMessage');
        info.textContent = msg;
        info.className = 'info-message ' + type;
      }
    }

    // 启动游戏
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded');
      new SudokuGame();
    });
  </script>
</body>
</html>